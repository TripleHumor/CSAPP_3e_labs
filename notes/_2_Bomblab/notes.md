这个lab主要功用是什么呢？我认为主要就是在这种小规模实战中进一步熟悉x86_64的指令集，机器级别的寄存器，内存状况，以及熟悉用汇编指令所表示的条件分支，循环，过程（这是整个过程中接触最频繁的一块，主要是要了解哪些寄存器会用来保存参数，栈上局部变量的分配（更简单点说，对栈帧的理解）），最后是锻炼通过反汇编来理解程序功能的能力（以及耐心！）

先简要介绍一下我做lab时主要用到的命令，工具等

objdump -D bomb > xxxx.md   //参数-D表示对所有section进行反汇编，这样查看虚拟内存中数据，代码位置也更方便些，后面的"> xxxx.md"是用来把结果保存到文件中方便查看
正好之前看vimtutor学了些vim的基操，剩下的工作就基本全靠vim来完成了，用vim来浏览代码也确实比较方便，主要是利用好/s来快速定位，比如全局变量，函数等等
拿纸笔做必要的笔记和分析，脑子作为缓存，容量有点可怜（我的）
gdb的话我个人没用到（不知道为啥我gdb命令红了…然后又懒得弄，就凑活了，hh暴露了，我一会就去整好），但是事后一想，使用gdb 1检查数据应该很方便（比如直接查看字符串内容）2gdb能够边运行边检查内容，
使用得当的话或许能节省不少时间，（人类有工具就该好好利用，悔过吧！）

首先观察题目给的bomb.c代码，了解大意，然后开始看反汇编代码，一开始可能摸不着头脑，每个函数都逐行分析的话那太慢了（比如我一开始的时候）
所以.c代码已有的部分在汇编中我们就大致跳过，尽量只看和bomb有关的代码，主要就是main函数和几个phase以及它们包含的函数，
并且一些函数的实现可以的话暂时先不细究而是根据命名来猜测其作用，(比如string_not_equal什么的可以猜得出是字符串不相等时返回1，相等返回0，粗略看看就可以确认了，这种放心的跳过就可以），
而且有些函数涉及到c库动态链接加载（第7章内容），直接看也看不到，需要百度一下函数的作用



那么目标还是很明确的，总共有6个phase，需要我们输入正确的指令来拆弹，所谓的拆弹实质上就是避开触发explode_bomb函数的条件，
而每个phase的条件就要具体代码具体分析了，主要记录些难点

main
主要从文件中读取输入，并且做了些初始化操作，不必过多关心

phase1
很短，可以看出就是条件是输入和指定字符串相同，定位好以后二进制码翻译成ASCII码就行

phase2
出现了函数 read_six_numbers,函数read_six_numbers内调用了__isoc99_sscanf，概述一下
sscanf（函数原型请自行搜索，c函数），是从给定字符串按指定格式读取数据到指定地址的变量中，返回值表示成功读取了几个数据
那read_six_numbers(具体请结合反汇编代码理解)的功能是按照指定格式读取数据到phase_2已分配的局部变量中去，这里是读了6个十进制整数，之后还会在phase_6遇到这个函数
继续读程序，发现其条件是，指定第一个参数为1，之后每个参数需要是前一个的2倍。

phase3
又见sscanf,容易看出是从输入读取2个数（存放到了0x8(%rsp)以及0xc(%rsp))，而输入的第一个参数要<=7,之后根据第一个参数会跳到某个位置* 0x402470(,%rax,8)（注意表示星号表示间接引用），
并且根据跳转位置来限制第二个参数的值，因为第一个参数可以有多种选择，因此这里答案不唯一，（0，207），（1，311），（2，707）……

phase4
又又见sscanf，易得输入是2个数，第一个数<=0xe
继续读，发现出现函数fun4，不妨先不理会它的具体实现，继续读发现输入的第二个数被限制为0，而且fun4的返回值被限制为0
此时我们再读fun4，此时只要想办法让它返回0即可，根据代码发现7可以满足（当然答案不唯一）
（这题我在fun4上浪费了不少无卵用的时间，试图搞懂它是干嘛的返回值的意义，后来才发现简单的一个0就够了，这里的教训是，要首先关注主要矛盾，如果不是必须，我们没必要关心无需知道的细节）

phase5
不见sscanf（你是不是觉得你很幽默），发现输入是个长度为6的字符串（题外话，read_line函数把换行符去了（好像），所以不用担心换行符）
这段代码总体上还是要使字符串和给定的相等，但是绕了一些
程序把每个输入字符的字节的低四位取到%rdx作为偏移量用来寻址0x4024b0(%rdx)并从对应地址取6个字节，之后再与给定的字符串比较（flyers）
于是我们只要寻址对应字节，让输入的低4位与对应地址的低四位相等就行了，答案并不唯一，只要字符的低4位依次是0x9,0xf,0xe,0x5,0x6,0x7

phase6
怎么说呢，phase6主要就是循环比较多，需要一个循环一个循环地去理清，
首先，有函数read_six_numbers,从输入读6个数字到栈上，
前两个循环限制了输入的每个数字<=6，
之后的循环，用7减去每个数字并替换栈对应位置上的值
再之后的循环，在栈上0x20(%rsp)开始,依次对应6个输入，存放地址（听我说可能不是很明白，务必亲自理解代码），我们发现所给地址0x6032d0指向的是一个单向的链表结构
再之后的循环，我们让各输入对应的链表节点顺序与输入的顺序相同（也就是依次设置了每个节点的指针）
最后，我们发现了限制条件，链表中靠前的节点的值要大于之后节点的值（而且有个小坑，需要注意到比较的是32位的大小而非64位，因为所用寄存器为%eax）
综合之前所有条件，就能得到正确答案

******************************
正如bomb.c文件中所说的，题目作者还藏了个炸弹，（虽然好像不找它也不会炸就是了）怎么找出来呢，我是在vim中搜索了所有explode_bomb,于是找到了隐藏的……

secret_phase !!!
它是藏在phase_defused中，满足一定条件才会被调用（0x603760对应的num_input_strings要等于6，要用sscanf成功从0x603870（0x603780 input_strings中的某处，距离为250）读出2个整数和1个字符串，而且这个字符串为DrEvil）（我暂时没精力去仔细调查这个0x603870，猜测是我们每个输入的字符串都会保存在input_strings的某处，但我想使用GDB来读的话或许就能够知道这个位置具体对应着输入的哪个位置了，可以的话就很容易了）我试出了需要在phase4的后面输入DrEvil才能在最后触发secret_phase
只要能触发一切都好说了
首先strtol函数把我们输入的字符串转换成相应的十进制整数
我们发现它其中调用了fun7（和fun4在很多方面很像），参数为0x6030f0（指向双向链表的一个节点，这个链表的特点是地址+0x8所指向的节点比它小，而地址+0x10指向的节点比它大），另一个参数就是我们的输入，
炸弹不炸的条件是输入的数的值<=1001，然后fun7返回2，因此我们研究出哪个值能够满足这个条件即可，在我的这道题目中，数值为22.

于是我也成长了那么一丢丢吧，去装gdb咯！
*******************************
gdb安装好了，已成功完成了secret_phase的定位，现在可以认为算是比较圆满地完成这个lab了，上传的图片就是使用gdb进行定位的截图. update 2021/3/14








