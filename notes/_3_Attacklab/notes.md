本lab主要目的，感觉主要是加深了对栈的理解，了解缓冲区溢出攻击的原理，以及为了对抗缓冲区溢出所采取的方法，认识到应避免gets()这类容易产生写越界的代码来增加代码的安全性

在本lab开始前，有必要好好读一下配套的http://csapp.cs.cmu.edu/3e/labs.html 中的Readme 以及Writeup，其中包含了lab的要求以及提示

Part 1
这一部分中代码没有采用栈随机化，也并未采用限制可执行代码区域的方法，所以可以轻易地在输入中插入代码执行攻击（code injection）

level 1
观察发现getbuf()函数分配了0x28（即40）字节存放字符串，只要通过溢出修改返回地址即可达到目的

level 2
除了返回到touch2函数外，还需要增加一个参数，因此我们有必要在输入中插入代码。
而因为没有栈随机化，我们可以通过使用gdb非常轻易地找到栈的地址，使程序返回到我们输入的代码（设置%rdi即参数，并设置%rsp），再返回touch2（）

level 3
相比touch2，变化的是参数需要成为一个字符串，因此我们的输入中既要有代码，也要有字符串数据，但是这并没什么难度，因为栈的地址非常容易获得，实现与touch2基本相同

Part 2
这一部分中的代码为了对抗缓冲区溢出攻击，采用了栈随机化，并且限制了我们的输入不可执行，因此需要采用新的攻击方法ROP，具体原理描述可以看Writeup，
这需要我们利用已存在的可执行代码段（需要后面紧接着ret指令），找到目标代码段后，我们在缓冲区溢出的部分填充代码地址或需要的数据，从而达成目的

level 4
需要实现与level 2同样的功能，具体实现方法是寻找代码段中隐含的pop和mov。（其中pop可以用来把cookie存到寄存器中，并且让%rsp指向下一个代码地址；之后移动cookie到%rdi，最后的地址指向touch2即可）

level 5
需要实现与level 3同样的功能，这一关的难度在于如何将字符串地址传递给%rdi，很惭愧想了很久没做出来，总结了一下想单靠文档里提供的movq，movl，popq，不能很好的获得指向数据的地址，
最好从代码段中找到了一段加法段，现成的或者截取的（lea或者add），通过加法来计算地址，将数据存放在那个地址
具体细节https://github.com/Exely/CSAPP-Labs/blob/master/notes/attack.md 讲的很好了，不赘述了
