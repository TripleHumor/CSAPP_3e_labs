在做本lab之前同样需要仔细阅读http://csapp.cs.cmu.edu/3e/labs.html中相应的Readme 以及Writeup，其中包含了详细的要求以及提示
Part A主要参考了https://www.geeksforgeeks.org/lru-cache-implementation/ ，了解了什么是LRU，具体实现以及其它各种靠自己
Part B主要参考了https://github.com/Exely/CSAPP-Labs/blob/master/notes/cachelab.md 
           以及 https://zhuanlan.zhihu.com/deeplearningcat

Part A
要求是C语言实现一个缓存模拟器
大佬们可能觉得很简单，但是我之前编程经验几乎为0，对于c的库不熟悉，等种种原因为了完成这一部分还是费了很大功夫，（尤其是debug各种segmentationfault几乎快绝望了……）
要说从这部分学到了什么，首先对于一些库函数更熟悉了，比如fopen，fgets等读取文件获取输入的函数，以及常见的字符串处理函数strtol，atol等
然后意识到了segmentation fault挺恶心的，有时候不经意的一个失误，但事后要定位就非常困难，
对这个缓存模拟器，我的不成熟的个人经验是，自我总结如下：
1在敲代码前，明确最后代码的功能应该是什么样的，然后进行拆解，拆成一个个模块
2拆解出的每个模块，在编写之前要完整考虑所有情况（当出现问题时，就分情况debug，并考虑是否有意外的情况发生）
3逐个功能模块的编写代码，测试完成后再进行下一个，这样很容易定位哪里出问题
4模块间也是有层次关系的，一般应该从上到下或者从下到上，总之要有顺序地完成；当模块之间存在相关性时，debug也要一起考虑进去（所以要尽量拆解设计的时候去耦合）

还有关于segment fault的一些总结：首先，出错原因是程序中有地方访问了不该访问的内存（比如NULL，比如要修改只读的地方，）
1确保使用的变量都记得初始化，特别是指针类型
2程序是否提防或考虑过NULL的情况，会如何处理NULL，最好在程序中加入关于NULL的报错
3修改程序时也要注意以上几点，避免未初始化的变量以及NULL相关的错误

难点的话，我觉得在于思考代码设计，LRU实现用到了队列（数据结构没好好学过），以及debug……
我的代码整体思路是

1准备工作，（1）读取命令行参数并进行适当的转换（出现可选参数-h时打印帮助并结束，出现-v时则要在之后的处理中额外打印具体情况）（2）读取trace文件
2根据参数初始化缓存数组(缓存的结构包括有效位，标记位，两个指针（因为用到队列来确定缓存的使用情况，队头是最近使用的，队尾就是当需要替换时的牺牲者）)
3逐行读取文件内容，并进行缓存命中判定，首先判断是否命中，不命中要分组内还有空位的情况以及需要替换的情况，无论命中与否，最后都要更新队列，以及更新计数

不足的话在于我写程序时没仔细看文档，没用getopt来处理命令行参数，使用的话或许程序会更简单
最后测试时发现其实只测试了结果的正确性，因此-h，-v就懒得具体写了，大致的结构已经搭好，内容没往里填，犯懒了


Part B
在Writeup中提到了Blocking的思路来解决问题，需要仔细阅读
因为题设的缓存是32组，每组1行，一行32块，所以最多存放1024个 字节，每一行最多容纳8个int类型数据
（总的来说这个lab花了我相当久，我想继续死磕实在进展太慢，所以决定看看前辈都怎么做的再反思，虽然遗憾自己没能攻克，以及掌握的肯定没亲手写的扎实，但是我觉得继续前进更重要）
总的来说，需要注意的点有1 缓存行的大小 2 缓存的总大小 3是否出现了缓存的竞争，替换

32 * 32的情况
很容易想到8 * 8的分块，但是要注意A和B对角线上的分块会出现缓存的竞争，为了解决竞争，考虑到题目允许栈上最多有12个变量，我们可以考虑将A中读取的值（一行）保留在这些变量中，之后再写入B，这样就能避免读写在对角线块上产生的抖动。

64* 64的情况
下意识认为还是8* 8的分块，但事实发现如果按照上一题的写法，4* 4的分块反而会更好（明明并没有充分利用缓存的完整一行），显然是因为出现了竞争，经过计算可以发现8* 8分块A的后4行会与前4行产生竞争；考虑过4* 16的分块，虽然避免了一定的竞争，但是当写入B时无法充分利用缓存，所以依然不够好；如何避免竞争，以及如何充分利用完整的1行缓存，具体解法请看最上参考的马天猫的CS学习之旅，说的很详细了，我尝试凭自己理解再总结一遍：
依然使用8* 8 分块，先专注于避免A的缓存竞争，我们取出A的前4行，保存到B，由于B同样存在竞争的问题，需要先将数据保存到B的前4行中（即B左下角的4* 4块要先保存在右上角）；
读取A的后4行（替换A的前4行，B的前4行仍然在缓存中），之后利用临时变量使得B的右上角和左下角的值逐行交换至正确位置（B的缓存在此同时逐行被替换），过程中不会产生miss；
最后将右下角也填入B中
对于在对角线上的分块，我们同32 * 32的情况一样，使用临时变量先读取后再写入B

我认为这思路没问题，于是想改善一下写法，临时变量用数组，但程序怎么调都0分，而马天猫同学的则一切正常……不知有无有缘人能看看……

PS：经过几个小时的调试，发现可能因为我选择了使用数组作为临时变量而没有使用8个单独定义的临时变量，一个猜想是因为数组在编译器看来不能存放在寄存器中，而单独定义的临时变量可以，如果是这种情况，那么就导致了在运行时每次引用数组形式的临时变量时就需要替换掉缓存中的内容产生冲突，因而miss会多很多
如果这篇笔记有人能看到的话，希望有大佬能回答我的这个猜测是否正确，就写个issue交流一哈


61* 67的情况
好像要求比较松，大家用16* 16的分块都过了，不多说了（试出来的，没有计算过，大概是这么分块缓存竞争比较少吧）
