在做本lab之前同样需要仔细阅读http://csapp.cs.cmu.edu/3e/labs.html中相应的Readme 以及Writeup，其中包含了详细的要求以及提示
Part A主要参考了https://www.geeksforgeeks.org/lru-cache-implementation/ ，了解了什么是LRU，具体实现以及其它各种靠自己
Part B主要参考了https://github.com/Exely/CSAPP-Labs/blob/master/notes/cachelab.md 
           以及 https://zhuanlan.zhihu.com/deeplearningcat

Part A
要求是C语言实现一个缓存模拟器
大佬们可能觉得很简单，但是我之前编程经验几乎为0，对于c的库不熟悉，等种种原因为了完成这一部分还是费了很大功夫，（尤其是debug各种segmentfault几乎快绝望了……）
要说从这部分学到了什么，首先对于一些库函数更熟悉了，比如fopen，fgets等读取文件获取输入的函数，以及常见的字符串处理函数strtol，atol等
然后意识到了segment fault挺恶心的，有时候不经意的一个失误，但事后要定位就非常困难，
对这个缓存模拟器，我的不成熟的个人经验是，自我总结如下：
1在敲代码前，明确最后代码的功能应该是什么样的，然后进行拆解，拆成一个个模块
2拆解出的每个模块，在编写之前要完整考虑所有情况（当出现问题时，就分情况debug，并考虑是否有意外的情况发生）
3逐个功能模块的编写代码，测试完成后再进行下一个，这样很容易定位哪里出问题
4模块间也是有层次关系的，一般应该从上到下或者从下到上，总之要有顺序地完成；当模块之间存在相关性时，debug也要一起考虑进去（所以要尽量拆解设计的时候去耦合）

还有关于segment fault的一些总结：首先，出错原因是程序中有地方访问了不该访问的内存（比如NULL，比如要修改只读的地方，）
1确保使用的变量都记得初始化，特别是指针类型
2程序是否提防或考虑过NULL的情况，会如何处理NULL，最好在程序中加入关于NULL的报错
3修改程序时也要注意以上几点，避免未初始化的变量以及NULL相关的错误

难点的话，我觉得在于思考代码设计，LRU实现用到了队列（数据结构没好好学过），以及debug……
我的代码整体思路是

1准备工作，（1）读取命令行参数并进行适当的转换（出现可选参数-h时打印帮助并结束，出现-v时则要在之后的处理中额外打印具体情况）（2）读取trace文件
2根据参数初始化缓存数组(缓存的结构包括有效位，标记位，两个指针（因为用到队列来确定缓存的使用情况，队头是最近使用的，队尾就是当需要替换时的牺牲者）)
3逐行读取文件内容，并进行缓存命中判定，首先判断是否命中，不命中要分组内还有空位的情况以及需要替换的情况，无论命中与否，最后都要更新队列，以及更新计数

不足的话在于我写程序时没仔细看文档，没用getopt来处理命令行参数，使用的话或许程序会更简单写


Part B
在Writeup中提到了Blocking的思路来解决问题，需要仔细阅读
因为题设的缓存是32组，每组1行，一行32块，所以最多存放1024个 字节，每一行最多容纳8个int类型数据
（总的来说这个lab花了我相当久，我想继续死磕实在进展太慢，所以决定看看前辈都怎么做的再反思，虽然遗憾自己没能攻克，以及掌握的肯定没亲手写的扎实，但是我觉得继续前进更重要）
总的来说，需要注意的点有1 缓存行的大小 2 缓存的总大小 3是否出现了缓存的竞争，替换

32 * 32的情况
很容易想到8 * 8的分块，但是要注意A和B对角线上的分块会出现缓存的竞争，需要处理的好一些，不然可能无法满分

64* 64的情况
下意识认为还是8* 8的分块，但事实发现如果按照32* 32的写法，4* 4的分块反而会更好（明明并没有充分利用缓存的完整一行），显然是因为出现了竞争；如何避免竞争具体解法请看
最上参考的马天猫的CS学习之旅，

61* 67的情况
好像要求比较松，大家用16* 16的分块都过了，不多说了
